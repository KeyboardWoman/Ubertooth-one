{:	data{I"/hardware/program/:ET{:default{	:	lastI"<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Project Ubertooth - Programming</title>
    <link rel="stylesheet" type="text/css" href="/style.css" media="screen">
    <meta name="generator" content="nanoc 3.1.6">
  </head>
  <body>
    <div id="main">
      <h1>Programming</h1>

<p>This page describes how to load compiled firmware onto an Ubertooth One or
Ubertooth Zero.  Other pages describe how to write <a
href="../../firmware/develop">firmware</a> or <a href="../../host/develop">host
code</a> for the platform.</p>

<p>There are three ways to program an Ubertooth board: the USB bootloader, the
ISP bootloader, and JTAG.</p>

<h2>USB bootloader</h2>

<p>This is the recommended method of loading code onto an Ubertooth Zero or
Ubertooth One provided that the USB bootloader is already installed (at the
time of manufacture, for example).  If you need to install the bootloader
itself, you will have to use either ISP or JTAG.</p>

<p>The bootloader executes every time the device starts up from reset or power
cycle.  Normally it just gets out of the way and passes control to the
application firmware very quickly.  Alternatively it can enter Device Firmware
Upgrade (DFU) mode which permits firmware upload and download over USB.  There
are two ways to tell the bootloader that you want it to enter DFU mode:</p>

<p>1. soft bootloader entry: By setting a flag in RAM, the application firmware
can instruct the bootloader to enter DFU mode following a reset (without loss
of power).  For example, with the bluetooth_rxtx firmware running you can
trigger a reset into DFU mode using 'ubertooth-util -f' (located in
host/bluetooth_rxtx/).  Soft entry only works on Ubertooth One, not Ubertooth
Zero.</p>

<p>2. hard bootloader entry (also known as pin entry): By connecting two pins
on the expansion header with a jumper during reset (either soft or hard boot),
you can force the bootloader into DFU mode.  When using pin entry, the
bootloader will enter DFU mode for only a few seconds and will then execute the
application if no DFU activity has started during that period.  This allows
developers to permanently or semi-permanently jumper the pins providing a DFU
opportunity on every reset.  This method works on Ubertooth One but not
Ubertooth Zero.</p>

<p>The bootloader indicates DFU mode by flashing the LEDs in a distinctive
pattern.  It also identifies itself as "usb_bootloader" on USB.</p>

<p>During DFU mode, firmware may be uploaded or downloaded using ubertooth-dfu.
See host/usb_dfu/README for usage instructions.</p>

<p>It is possible that soft bootloader entry may be broken by installing a
faulty application or an application that does not provide a method of
triggering soft entry.  In this case, pin entry must be used (e.g. by holding a
paper clip in the expansion header while plugging in the device) to "unbrick"
the unit.</p>

<p>For Ubertooth One, the pins to connect are pins 1 and 3 of the <a
href="../one/#pins">expansion header (P4)</a>.  For Ubertooth Zero, the pins to
connect are pins 1 and 13 of the expansion header (J1).</p>

<h2>ISP bootloader</h2>

<p>The LPC175x features an In-System Programming (ISP) bootloader that allows
code to be loaded over a serial interface.  In order to use ISP, you will need
<a href="http://sourceforge.net/projects/lpc21isp/">lpc21isp</a> and a 3.3V
serial programming device such as one of the following:</p>

<h3>Pogoprog</h3>

<p>The official Ubertooth ISP programmer is Pogoprog, an open source board that
can be assembled using a process similar to Ubertooth One assembly.</p>

<h3>an FTDI Basic Breakout - 3.3V</h3>

<p>You can use SparkFun's <a href="http://www.sparkfun.com/products/9873">FTDI
Basic Breakout - 3.3V</a> to program an Ubertooth.  Adafruit's <a
href="http://www.adafruit.com/index.php?main_page=product_info&products_id=284">FTDI
Friend</a> is a similar board that should work as well.  To allow lpc21isp to
automatically activate the LPC175x's ISP bootloader, you must modify the board
in one of two ways.</p>

<h4>method one: the easy way</h4>

<p>Just short the CTS pin to GND.  This will force the microcontroller into ISP
mode every time it resets while the programmer is connected.  In order to
perform a normal reset to run the newly loaded code, you will have to first
disconnect the programmer.</p>

<h4>method two: the better way</h4>

<p>Connect the CTS pin to the RTS pin (pin 3) on the FT232RL using fine gauge
wire such as wire wrap wire.  This is trickier to solder, but it has the
advantage that the pin will be fully controlled by lpc21isp.  This means that
you can leave the programmer connected to the Ubertooth board throughout
multiple program/test cycles.</p>

<h3>using ISP</h3>

<img src="../../images/pogoprog-placement.jpeg" alt="Pogoprog placement" />

<p>Warning: Code loaded via ISP will blow away the bootloader.  It is generally
recommended to use this method only for installing the bootloader itself.</p>

<p>Connect your serial programmer to the Ubertooth board and type &quot;make
program&quot; in the firmware source code directory.  If you have a precompiled
binary in .hex format, you can invoke lpc21isp directly with &quot;lpc21isp
-control firmware.hex /dev/ttyUSB0 230400 4000&quot; (replacing firmware.hex
with the firmware filename and /dev/ttyUSB0 with the device file of your serial
programmer.</p>

<h2>JTAG</h2>

<p>Warning: Code loaded via JTAG will blow away the bootloader.  It is
generally recommended to use this method only for installing the bootloader
itself.</p>

<p>Connect your ARM Cortex-M3 JTAG debugger (such as one supported by <a
href="http://openocd.berlios.de/web/">OpenOCD</a>) to the standard Cortex Debug
Connector on the Ubertooth One or the non-standard JTAG connector on the
Ubertooth Zero.  You know what to do.</p>

    </div>
    <div id="sidebar">
      <h1>Project Ubertooth</h1>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki">home</a></li>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/releases">download</a></li>
      </ul>
      <h2>usage</h2>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Getting-Started">getting started</a></li>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Build-Guide">build guide</a></li>
      </ul>
      <h2>hardware</h2>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Ubertooth-Zero">Ubertooth Zero</a></li>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Ubertooth-One">Ubertooth One</a></li>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Assembling-Hardware">build guide</a></li>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Programming">programming</a></li>
      </ul>
      <h2>firmware</h2>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Firmware">developing</a></li>
      </ul>
      <h2>host code</h2>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Software">developing</a></li>
      </ul>
      <h2>help</h2>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Getting-Help">Getting Help</a></li>
        <li><a href="https://lists.sourceforge.net/lists/listinfo/ubertooth-general">mailing list</a></li>
      </ul>
    </div>
  </body>
</html>
;T:rawI" <h1>Programming</h1>

<p>This page describes how to load compiled firmware onto an Ubertooth One or
Ubertooth Zero.  Other pages describe how to write <a
href="../../firmware/develop">firmware</a> or <a href="../../host/develop">host
code</a> for the platform.</p>

<p>There are three ways to program an Ubertooth board: the USB bootloader, the
ISP bootloader, and JTAG.</p>

<h2>USB bootloader</h2>

<p>This is the recommended method of loading code onto an Ubertooth Zero or
Ubertooth One provided that the USB bootloader is already installed (at the
time of manufacture, for example).  If you need to install the bootloader
itself, you will have to use either ISP or JTAG.</p>

<p>The bootloader executes every time the device starts up from reset or power
cycle.  Normally it just gets out of the way and passes control to the
application firmware very quickly.  Alternatively it can enter Device Firmware
Upgrade (DFU) mode which permits firmware upload and download over USB.  There
are two ways to tell the bootloader that you want it to enter DFU mode:</p>

<p>1. soft bootloader entry: By setting a flag in RAM, the application firmware
can instruct the bootloader to enter DFU mode following a reset (without loss
of power).  For example, with the bluetooth_rxtx firmware running you can
trigger a reset into DFU mode using 'ubertooth-util -f' (located in
host/bluetooth_rxtx/).  Soft entry only works on Ubertooth One, not Ubertooth
Zero.</p>

<p>2. hard bootloader entry (also known as pin entry): By connecting two pins
on the expansion header with a jumper during reset (either soft or hard boot),
you can force the bootloader into DFU mode.  When using pin entry, the
bootloader will enter DFU mode for only a few seconds and will then execute the
application if no DFU activity has started during that period.  This allows
developers to permanently or semi-permanently jumper the pins providing a DFU
opportunity on every reset.  This method works on Ubertooth One but not
Ubertooth Zero.</p>

<p>The bootloader indicates DFU mode by flashing the LEDs in a distinctive
pattern.  It also identifies itself as "usb_bootloader" on USB.</p>

<p>During DFU mode, firmware may be uploaded or downloaded using ubertooth-dfu.
See host/usb_dfu/README for usage instructions.</p>

<p>It is possible that soft bootloader entry may be broken by installing a
faulty application or an application that does not provide a method of
triggering soft entry.  In this case, pin entry must be used (e.g. by holding a
paper clip in the expansion header while plugging in the device) to "unbrick"
the unit.</p>

<p>For Ubertooth One, the pins to connect are pins 1 and 3 of the <a
href="../one/#pins">expansion header (P4)</a>.  For Ubertooth Zero, the pins to
connect are pins 1 and 13 of the expansion header (J1).</p>

<h2>ISP bootloader</h2>

<p>The LPC175x features an In-System Programming (ISP) bootloader that allows
code to be loaded over a serial interface.  In order to use ISP, you will need
<a href="http://sourceforge.net/projects/lpc21isp/">lpc21isp</a> and a 3.3V
serial programming device such as one of the following:</p>

<h3>Pogoprog</h3>

<p>The official Ubertooth ISP programmer is Pogoprog, an open source board that
can be assembled using a process similar to Ubertooth One assembly.</p>

<h3>an FTDI Basic Breakout - 3.3V</h3>

<p>You can use SparkFun's <a href="http://www.sparkfun.com/products/9873">FTDI
Basic Breakout - 3.3V</a> to program an Ubertooth.  Adafruit's <a
href="http://www.adafruit.com/index.php?main_page=product_info&products_id=284">FTDI
Friend</a> is a similar board that should work as well.  To allow lpc21isp to
automatically activate the LPC175x's ISP bootloader, you must modify the board
in one of two ways.</p>

<h4>method one: the easy way</h4>

<p>Just short the CTS pin to GND.  This will force the microcontroller into ISP
mode every time it resets while the programmer is connected.  In order to
perform a normal reset to run the newly loaded code, you will have to first
disconnect the programmer.</p>

<h4>method two: the better way</h4>

<p>Connect the CTS pin to the RTS pin (pin 3) on the FT232RL using fine gauge
wire such as wire wrap wire.  This is trickier to solder, but it has the
advantage that the pin will be fully controlled by lpc21isp.  This means that
you can leave the programmer connected to the Ubertooth board throughout
multiple program/test cycles.</p>

<h3>using ISP</h3>

<img src="../../images/pogoprog-placement.jpeg" alt="Pogoprog placement" />

<p>Warning: Code loaded via ISP will blow away the bootloader.  It is generally
recommended to use this method only for installing the bootloader itself.</p>

<p>Connect your serial programmer to the Ubertooth board and type &quot;make
program&quot; in the firmware source code directory.  If you have a precompiled
binary in .hex format, you can invoke lpc21isp directly with &quot;lpc21isp
-control firmware.hex /dev/ttyUSB0 230400 4000&quot; (replacing firmware.hex
with the firmware filename and /dev/ttyUSB0 with the device file of your serial
programmer.</p>

<h2>JTAG</h2>

<p>Warning: Code loaded via JTAG will blow away the bootloader.  It is
generally recommended to use this method only for installing the bootloader
itself.</p>

<p>Connect your ARM Cortex-M3 JTAG debugger (such as one supported by <a
href="http://openocd.berlios.de/web/">OpenOCD</a>) to the standard Cortex Debug
Connector on the Ubertooth One or the non-standard JTAG connector on the
Ubertooth Zero.  You know what to do.</p>
;T:preI" <h1>Programming</h1>

<p>This page describes how to load compiled firmware onto an Ubertooth One or
Ubertooth Zero.  Other pages describe how to write <a
href="../../firmware/develop">firmware</a> or <a href="../../host/develop">host
code</a> for the platform.</p>

<p>There are three ways to program an Ubertooth board: the USB bootloader, the
ISP bootloader, and JTAG.</p>

<h2>USB bootloader</h2>

<p>This is the recommended method of loading code onto an Ubertooth Zero or
Ubertooth One provided that the USB bootloader is already installed (at the
time of manufacture, for example).  If you need to install the bootloader
itself, you will have to use either ISP or JTAG.</p>

<p>The bootloader executes every time the device starts up from reset or power
cycle.  Normally it just gets out of the way and passes control to the
application firmware very quickly.  Alternatively it can enter Device Firmware
Upgrade (DFU) mode which permits firmware upload and download over USB.  There
are two ways to tell the bootloader that you want it to enter DFU mode:</p>

<p>1. soft bootloader entry: By setting a flag in RAM, the application firmware
can instruct the bootloader to enter DFU mode following a reset (without loss
of power).  For example, with the bluetooth_rxtx firmware running you can
trigger a reset into DFU mode using 'ubertooth-util -f' (located in
host/bluetooth_rxtx/).  Soft entry only works on Ubertooth One, not Ubertooth
Zero.</p>

<p>2. hard bootloader entry (also known as pin entry): By connecting two pins
on the expansion header with a jumper during reset (either soft or hard boot),
you can force the bootloader into DFU mode.  When using pin entry, the
bootloader will enter DFU mode for only a few seconds and will then execute the
application if no DFU activity has started during that period.  This allows
developers to permanently or semi-permanently jumper the pins providing a DFU
opportunity on every reset.  This method works on Ubertooth One but not
Ubertooth Zero.</p>

<p>The bootloader indicates DFU mode by flashing the LEDs in a distinctive
pattern.  It also identifies itself as "usb_bootloader" on USB.</p>

<p>During DFU mode, firmware may be uploaded or downloaded using ubertooth-dfu.
See host/usb_dfu/README for usage instructions.</p>

<p>It is possible that soft bootloader entry may be broken by installing a
faulty application or an application that does not provide a method of
triggering soft entry.  In this case, pin entry must be used (e.g. by holding a
paper clip in the expansion header while plugging in the device) to "unbrick"
the unit.</p>

<p>For Ubertooth One, the pins to connect are pins 1 and 3 of the <a
href="../one/#pins">expansion header (P4)</a>.  For Ubertooth Zero, the pins to
connect are pins 1 and 13 of the expansion header (J1).</p>

<h2>ISP bootloader</h2>

<p>The LPC175x features an In-System Programming (ISP) bootloader that allows
code to be loaded over a serial interface.  In order to use ISP, you will need
<a href="http://sourceforge.net/projects/lpc21isp/">lpc21isp</a> and a 3.3V
serial programming device such as one of the following:</p>

<h3>Pogoprog</h3>

<p>The official Ubertooth ISP programmer is Pogoprog, an open source board that
can be assembled using a process similar to Ubertooth One assembly.</p>

<h3>an FTDI Basic Breakout - 3.3V</h3>

<p>You can use SparkFun's <a href="http://www.sparkfun.com/products/9873">FTDI
Basic Breakout - 3.3V</a> to program an Ubertooth.  Adafruit's <a
href="http://www.adafruit.com/index.php?main_page=product_info&products_id=284">FTDI
Friend</a> is a similar board that should work as well.  To allow lpc21isp to
automatically activate the LPC175x's ISP bootloader, you must modify the board
in one of two ways.</p>

<h4>method one: the easy way</h4>

<p>Just short the CTS pin to GND.  This will force the microcontroller into ISP
mode every time it resets while the programmer is connected.  In order to
perform a normal reset to run the newly loaded code, you will have to first
disconnect the programmer.</p>

<h4>method two: the better way</h4>

<p>Connect the CTS pin to the RTS pin (pin 3) on the FT232RL using fine gauge
wire such as wire wrap wire.  This is trickier to solder, but it has the
advantage that the pin will be fully controlled by lpc21isp.  This means that
you can leave the programmer connected to the Ubertooth board throughout
multiple program/test cycles.</p>

<h3>using ISP</h3>

<img src="../../images/pogoprog-placement.jpeg" alt="Pogoprog placement" />

<p>Warning: Code loaded via ISP will blow away the bootloader.  It is generally
recommended to use this method only for installing the bootloader itself.</p>

<p>Connect your serial programmer to the Ubertooth board and type &quot;make
program&quot; in the firmware source code directory.  If you have a precompiled
binary in .hex format, you can invoke lpc21isp directly with &quot;lpc21isp
-control firmware.hex /dev/ttyUSB0 230400 4000&quot; (replacing firmware.hex
with the firmware filename and /dev/ttyUSB0 with the device file of your serial
programmer.</p>

<h2>JTAG</h2>

<p>Warning: Code loaded via JTAG will blow away the bootloader.  It is
generally recommended to use this method only for installing the bootloader
itself.</p>

<p>Connect your ARM Cortex-M3 JTAG debugger (such as one supported by <a
href="http://openocd.berlios.de/web/">OpenOCD</a>) to the standard Cortex Debug
Connector on the Ubertooth One or the non-standard JTAG connector on the
Ubertooth Zero.  You know what to do.</p>
;T:	post@
I"/hardware/zero/;T{;{	;I"û<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Project Ubertooth - Ubertooth Zero</title>
    <link rel="stylesheet" type="text/css" href="/style.css" media="screen">
    <meta name="generator" content="nanoc 3.1.6">
  </head>
  <body>
    <div id="main">
      <h1>Ubertooth Zero</h1>

<p>Ubertooth Zero was the first working prototype hardware platform of Project
Ubertooth.  It has been superseded by <a href="../one/">Ubertooth One</a>.</p>

<img src="../../images/ubertooth-zero.jpeg" alt="Ubertooth Zero photo" />

<h2>architecture</h2>

<ul>
	<li><a href="http://en.wikipedia.org/wiki/SMA_connector">RP-SMA</a> RF
	connector: connects to test equipment, antenna, or dummy load.</li>
	<li><a
	href="http://focus.ti.com/docs/prod/folders/print/cc2400.html">CC2400</a>
	wireless transceiver IC.</li>
	<li><a href="http://ics.nxp.com/products/lpc1000/lpc17xx/">LPC175x</a> ARM
	Cortex-M3 microcontroller with Full-Speed USB 2.0.</li>
	<li>USB A plug: connects to host computer running Kismet or other host
	code.</li>
</ul>

<h2>features</h2>

<ul>
	<li>2.4 GHz transmit and receive.</li>
	<li>Transmit power and receive sensitivity comparable to a Class 3
	Bluetooth device.</li>
	<li>non-standard JTAG connector.</li>
	<li>In-System Programming (ISP) serial connector.</li>
	<li>expansion connector: intended for inter-Ubertooth communication or
	other future uses.</li>
	<li>six indicator LEDs.</li>
</ul>

<h2>design</h2>

<p>Ubertooth Zero was designed in <a href="http://www.cadsoft.de/">CadSoft
EAGLE</a> with surface mount components suitable for <a
href="http://www.sparkfun.com/tutorials/59">reflow</a>.

<h2>demonstration</h2>

<p>Michael Ossmann presented <em>Ubertooth Zero, a preview</em> (video: <a
href="http://www.youtube.com/watch?v=m87gn7uOBGs">part 1</a>, <a
href="http://www.youtube.com/watch?v=OAC8SmdwGBY">part 2</a>) at <a
href="http://sandiego.toorcon.org/">ToorCon 12</a> in October, 2010.</p>

    </div>
    <div id="sidebar">
      <h1>Project Ubertooth</h1>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki">home</a></li>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/releases">download</a></li>
      </ul>
      <h2>usage</h2>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Getting-Started">getting started</a></li>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Build-Guide">build guide</a></li>
      </ul>
      <h2>hardware</h2>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Ubertooth-Zero">Ubertooth Zero</a></li>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Ubertooth-One">Ubertooth One</a></li>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Assembling-Hardware">build guide</a></li>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Programming">programming</a></li>
      </ul>
      <h2>firmware</h2>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Firmware">developing</a></li>
      </ul>
      <h2>host code</h2>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Software">developing</a></li>
      </ul>
      <h2>help</h2>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Getting-Help">Getting Help</a></li>
        <li><a href="https://lists.sourceforge.net/lists/listinfo/ubertooth-general">mailing list</a></li>
      </ul>
    </div>
  </body>
</html>
;T;	I"}<h1>Ubertooth Zero</h1>

<p>Ubertooth Zero was the first working prototype hardware platform of Project
Ubertooth.  It has been superseded by <a href="../one/">Ubertooth One</a>.</p>

<img src="../../images/ubertooth-zero.jpeg" alt="Ubertooth Zero photo" />

<h2>architecture</h2>

<ul>
	<li><a href="http://en.wikipedia.org/wiki/SMA_connector">RP-SMA</a> RF
	connector: connects to test equipment, antenna, or dummy load.</li>
	<li><a
	href="http://focus.ti.com/docs/prod/folders/print/cc2400.html">CC2400</a>
	wireless transceiver IC.</li>
	<li><a href="http://ics.nxp.com/products/lpc1000/lpc17xx/">LPC175x</a> ARM
	Cortex-M3 microcontroller with Full-Speed USB 2.0.</li>
	<li>USB A plug: connects to host computer running Kismet or other host
	code.</li>
</ul>

<h2>features</h2>

<ul>
	<li>2.4 GHz transmit and receive.</li>
	<li>Transmit power and receive sensitivity comparable to a Class 3
	Bluetooth device.</li>
	<li>non-standard JTAG connector.</li>
	<li>In-System Programming (ISP) serial connector.</li>
	<li>expansion connector: intended for inter-Ubertooth communication or
	other future uses.</li>
	<li>six indicator LEDs.</li>
</ul>

<h2>design</h2>

<p>Ubertooth Zero was designed in <a href="http://www.cadsoft.de/">CadSoft
EAGLE</a> with surface mount components suitable for <a
href="http://www.sparkfun.com/tutorials/59">reflow</a>.

<h2>demonstration</h2>

<p>Michael Ossmann presented <em>Ubertooth Zero, a preview</em> (video: <a
href="http://www.youtube.com/watch?v=m87gn7uOBGs">part 1</a>, <a
href="http://www.youtube.com/watch?v=OAC8SmdwGBY">part 2</a>) at <a
href="http://sandiego.toorcon.org/">ToorCon 12</a> in October, 2010.</p>
;T;
I"}<h1>Ubertooth Zero</h1>

<p>Ubertooth Zero was the first working prototype hardware platform of Project
Ubertooth.  It has been superseded by <a href="../one/">Ubertooth One</a>.</p>

<img src="../../images/ubertooth-zero.jpeg" alt="Ubertooth Zero photo" />

<h2>architecture</h2>

<ul>
	<li><a href="http://en.wikipedia.org/wiki/SMA_connector">RP-SMA</a> RF
	connector: connects to test equipment, antenna, or dummy load.</li>
	<li><a
	href="http://focus.ti.com/docs/prod/folders/print/cc2400.html">CC2400</a>
	wireless transceiver IC.</li>
	<li><a href="http://ics.nxp.com/products/lpc1000/lpc17xx/">LPC175x</a> ARM
	Cortex-M3 microcontroller with Full-Speed USB 2.0.</li>
	<li>USB A plug: connects to host computer running Kismet or other host
	code.</li>
</ul>

<h2>features</h2>

<ul>
	<li>2.4 GHz transmit and receive.</li>
	<li>Transmit power and receive sensitivity comparable to a Class 3
	Bluetooth device.</li>
	<li>non-standard JTAG connector.</li>
	<li>In-System Programming (ISP) serial connector.</li>
	<li>expansion connector: intended for inter-Ubertooth communication or
	other future uses.</li>
	<li>six indicator LEDs.</li>
</ul>

<h2>design</h2>

<p>Ubertooth Zero was designed in <a href="http://www.cadsoft.de/">CadSoft
EAGLE</a> with surface mount components suitable for <a
href="http://www.sparkfun.com/tutorials/59">reflow</a>.

<h2>demonstration</h2>

<p>Michael Ossmann presented <em>Ubertooth Zero, a preview</em> (video: <a
href="http://www.youtube.com/watch?v=m87gn7uOBGs">part 1</a>, <a
href="http://www.youtube.com/watch?v=OAC8SmdwGBY">part 2</a>) at <a
href="http://sandiego.toorcon.org/">ToorCon 12</a> in October, 2010.</p>
;T;@I"/hardware/one/;T{;{	;I"3<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Project Ubertooth - Ubertooth One</title>
    <link rel="stylesheet" type="text/css" href="/style.css" media="screen">
    <meta name="generator" content="nanoc 3.1.6">
  </head>
  <body>
    <div id="main">
      <h1>Ubertooth One</h1>

<p>Ubertooth One is the next generation hardware platform of Project Ubertooth.
It supersedes <a href="../zero/">Ubertooth Zero</a> and is currently the
preferred platform.</p>

<img src="../../images/ubertooth-one.jpeg" alt="Ubertooth One photo" />

<h2>architecture</h2>

<ul>
	<li><a href="http://en.wikipedia.org/wiki/SMA_connector">RP-SMA</a> RF
	connector: connects to test equipment, antenna, or dummy load.</li>
	<li><a
	href="http://focus.ti.com/docs/prod/folders/print/cc2591.html">CC2591</a>
	RF front end.</li>
	<li><a
	href="http://focus.ti.com/docs/prod/folders/print/cc2400.html">CC2400</a>
	wireless transceiver.</li>
	<li><a href="http://ics.nxp.com/products/lpc1000/lpc17xx/">LPC175x</a> ARM
	Cortex-M3 microcontroller with Full-Speed USB 2.0.</li>
	<li>USB A plug: connects to host computer running Kismet or other host
	code.</li>
</ul>

<h2>features</h2>

<ul>
	<li>2.4 GHz transmit and receive.</li>
	<li>Transmit power and receive sensitivity comparable to a Class 1
	Bluetooth device.</li>
	<li>standard <a
	href="http://infocenter.arm.com/help/topic/com.arm.doc.faqs/attached/13634/cortex_debug_connectors.pdf">Cortex
	Debug Connector</a> (10-pin 50-mil JTAG).</li>
	<li>In-System Programming (ISP) serial connector.</li>
	<li>expansion connector: intended for inter-Ubertooth communication or
	other future uses.</li>
	<li>six indicator LEDs.</li>
</ul>

<h2>design</h2>

<p>Ubertooth One was designed in <a
href="http://kicad.sourceforge.net/wiki/index.php/Main_Page">KiCad</a>, an open
source electronic design automation software package, with surface mount
components suitable for <a
href="http://www.sparkfun.com/tutorials/59">reflow</a>.</p>

<h2><a name="pins" />pins and LEDs</h2>

<img src="../../images/u1_roadmap.png" alt="Ubertooth One diagram" />

<p>This diagram shows the location of LEDs and the pins of the expansion
connector.</p>

<p>LED guide:</p>

<ul>
	<li>RST: indicates that the LPC175x is powered on. This should always be on
	during operation except during a full reset of the LPC175x (e.g., while
	entering ISP mode).</li>
	<li>1V8: indicates that the CC2400 is being supplied with 1.8 V. Control of
	this supply depends on firmware. 1V8 power is required to activate the
	crystal oscillator which is required to activate USB.</li>
	<li>USB: indicates that USB has passed enumeration and configuration.</li>
	<li>TX: Control of this LED depends on firmware. It typically indicates
	radio transmission.</li>
	<li>RX: Control of this LED depends on firmware. It typically indicates
	radio reception.</li>
	<li>USR: Control of this LED depends on firmware.</li>
</ul>

<p>The TX, RX, and USR LEDs blink in a distinctive chasing pattern when the
bootloader is ready to accept USB DFU commands.</p>

<h2>demonstration</h2>

<p>Michael Ossmann presented <a
href="http://www.shmoocon.org/schedule#ubertooth">Project Ubertooth: Building a
Better Bluetooth Adapter</a> at <a href="http://www.shmoocon.org/">ShmooCon</a>
2011.</p>

    </div>
    <div id="sidebar">
      <h1>Project Ubertooth</h1>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki">home</a></li>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/releases">download</a></li>
      </ul>
      <h2>usage</h2>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Getting-Started">getting started</a></li>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Build-Guide">build guide</a></li>
      </ul>
      <h2>hardware</h2>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Ubertooth-Zero">Ubertooth Zero</a></li>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Ubertooth-One">Ubertooth One</a></li>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Assembling-Hardware">build guide</a></li>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Programming">programming</a></li>
      </ul>
      <h2>firmware</h2>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Firmware">developing</a></li>
      </ul>
      <h2>host code</h2>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Software">developing</a></li>
      </ul>
      <h2>help</h2>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Getting-Help">Getting Help</a></li>
        <li><a href="https://lists.sourceforge.net/lists/listinfo/ubertooth-general">mailing list</a></li>
      </ul>
    </div>
  </body>
</html>
;T;	I"¶<h1>Ubertooth One</h1>

<p>Ubertooth One is the next generation hardware platform of Project Ubertooth.
It supersedes <a href="../zero/">Ubertooth Zero</a> and is currently the
preferred platform.</p>

<img src="../../images/ubertooth-one.jpeg" alt="Ubertooth One photo" />

<h2>architecture</h2>

<ul>
	<li><a href="http://en.wikipedia.org/wiki/SMA_connector">RP-SMA</a> RF
	connector: connects to test equipment, antenna, or dummy load.</li>
	<li><a
	href="http://focus.ti.com/docs/prod/folders/print/cc2591.html">CC2591</a>
	RF front end.</li>
	<li><a
	href="http://focus.ti.com/docs/prod/folders/print/cc2400.html">CC2400</a>
	wireless transceiver.</li>
	<li><a href="http://ics.nxp.com/products/lpc1000/lpc17xx/">LPC175x</a> ARM
	Cortex-M3 microcontroller with Full-Speed USB 2.0.</li>
	<li>USB A plug: connects to host computer running Kismet or other host
	code.</li>
</ul>

<h2>features</h2>

<ul>
	<li>2.4 GHz transmit and receive.</li>
	<li>Transmit power and receive sensitivity comparable to a Class 1
	Bluetooth device.</li>
	<li>standard <a
	href="http://infocenter.arm.com/help/topic/com.arm.doc.faqs/attached/13634/cortex_debug_connectors.pdf">Cortex
	Debug Connector</a> (10-pin 50-mil JTAG).</li>
	<li>In-System Programming (ISP) serial connector.</li>
	<li>expansion connector: intended for inter-Ubertooth communication or
	other future uses.</li>
	<li>six indicator LEDs.</li>
</ul>

<h2>design</h2>

<p>Ubertooth One was designed in <a
href="http://kicad.sourceforge.net/wiki/index.php/Main_Page">KiCad</a>, an open
source electronic design automation software package, with surface mount
components suitable for <a
href="http://www.sparkfun.com/tutorials/59">reflow</a>.</p>

<h2><a name="pins" />pins and LEDs</h2>

<img src="../../images/u1_roadmap.png" alt="Ubertooth One diagram" />

<p>This diagram shows the location of LEDs and the pins of the expansion
connector.</p>

<p>LED guide:</p>

<ul>
	<li>RST: indicates that the LPC175x is powered on. This should always be on
	during operation except during a full reset of the LPC175x (e.g., while
	entering ISP mode).</li>
	<li>1V8: indicates that the CC2400 is being supplied with 1.8 V. Control of
	this supply depends on firmware. 1V8 power is required to activate the
	crystal oscillator which is required to activate USB.</li>
	<li>USB: indicates that USB has passed enumeration and configuration.</li>
	<li>TX: Control of this LED depends on firmware. It typically indicates
	radio transmission.</li>
	<li>RX: Control of this LED depends on firmware. It typically indicates
	radio reception.</li>
	<li>USR: Control of this LED depends on firmware.</li>
</ul>

<p>The TX, RX, and USR LEDs blink in a distinctive chasing pattern when the
bootloader is ready to accept USB DFU commands.</p>

<h2>demonstration</h2>

<p>Michael Ossmann presented <a
href="http://www.shmoocon.org/schedule#ubertooth">Project Ubertooth: Building a
Better Bluetooth Adapter</a> at <a href="http://www.shmoocon.org/">ShmooCon</a>
2011.</p>
;T;
I"¶<h1>Ubertooth One</h1>

<p>Ubertooth One is the next generation hardware platform of Project Ubertooth.
It supersedes <a href="../zero/">Ubertooth Zero</a> and is currently the
preferred platform.</p>

<img src="../../images/ubertooth-one.jpeg" alt="Ubertooth One photo" />

<h2>architecture</h2>

<ul>
	<li><a href="http://en.wikipedia.org/wiki/SMA_connector">RP-SMA</a> RF
	connector: connects to test equipment, antenna, or dummy load.</li>
	<li><a
	href="http://focus.ti.com/docs/prod/folders/print/cc2591.html">CC2591</a>
	RF front end.</li>
	<li><a
	href="http://focus.ti.com/docs/prod/folders/print/cc2400.html">CC2400</a>
	wireless transceiver.</li>
	<li><a href="http://ics.nxp.com/products/lpc1000/lpc17xx/">LPC175x</a> ARM
	Cortex-M3 microcontroller with Full-Speed USB 2.0.</li>
	<li>USB A plug: connects to host computer running Kismet or other host
	code.</li>
</ul>

<h2>features</h2>

<ul>
	<li>2.4 GHz transmit and receive.</li>
	<li>Transmit power and receive sensitivity comparable to a Class 1
	Bluetooth device.</li>
	<li>standard <a
	href="http://infocenter.arm.com/help/topic/com.arm.doc.faqs/attached/13634/cortex_debug_connectors.pdf">Cortex
	Debug Connector</a> (10-pin 50-mil JTAG).</li>
	<li>In-System Programming (ISP) serial connector.</li>
	<li>expansion connector: intended for inter-Ubertooth communication or
	other future uses.</li>
	<li>six indicator LEDs.</li>
</ul>

<h2>design</h2>

<p>Ubertooth One was designed in <a
href="http://kicad.sourceforge.net/wiki/index.php/Main_Page">KiCad</a>, an open
source electronic design automation software package, with surface mount
components suitable for <a
href="http://www.sparkfun.com/tutorials/59">reflow</a>.</p>

<h2><a name="pins" />pins and LEDs</h2>

<img src="../../images/u1_roadmap.png" alt="Ubertooth One diagram" />

<p>This diagram shows the location of LEDs and the pins of the expansion
connector.</p>

<p>LED guide:</p>

<ul>
	<li>RST: indicates that the LPC175x is powered on. This should always be on
	during operation except during a full reset of the LPC175x (e.g., while
	entering ISP mode).</li>
	<li>1V8: indicates that the CC2400 is being supplied with 1.8 V. Control of
	this supply depends on firmware. 1V8 power is required to activate the
	crystal oscillator which is required to activate USB.</li>
	<li>USB: indicates that USB has passed enumeration and configuration.</li>
	<li>TX: Control of this LED depends on firmware. It typically indicates
	radio transmission.</li>
	<li>RX: Control of this LED depends on firmware. It typically indicates
	radio reception.</li>
	<li>USR: Control of this LED depends on firmware.</li>
</ul>

<p>The TX, RX, and USR LEDs blink in a distinctive chasing pattern when the
bootloader is ready to accept USB DFU commands.</p>

<h2>demonstration</h2>

<p>Michael Ossmann presented <a
href="http://www.shmoocon.org/schedule#ubertooth">Project Ubertooth: Building a
Better Bluetooth Adapter</a> at <a href="http://www.shmoocon.org/">ShmooCon</a>
2011.</p>
;T;@I"/hardware/build/;T{;{	;I"©&<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Project Ubertooth - Hardware Build Guide</title>
    <link rel="stylesheet" type="text/css" href="/style.css" media="screen">
    <meta name="generator" content="nanoc 3.1.6">
  </head>
  <body>
    <div id="main">
      <h1>Hardware Build Guide</h1>

<p>This describes the build process for Ubertooth One, but the processes for
Ubertooth Zero and Pogoprog are essentially the same.</p>

<h2>step 0: read these instructions</h2>

<p>Seriously.  There are probably things in the later steps that you should
know about before getting started.</p>

<h2>step 1: order a PCB</h2>

<p>You will need a four layer printed circuit board.  I recommend using Laen's
PCB service at <a href="http://dorkbotpdx.org/wiki/pcb_order">DorkbotPDX</a>.
Take the Ubertooth One Gerber files from the most recent Project Ubertooth
release package (or generate them with KiCad) and send them to Laen.  The board
is 1.8 square inches, so it will cost $18 per set of three.  That's one for
yourself, one for a friend, and one to screw up!  If you live on Mars and can't
get a four layer board manufactured, Ubertooth Zero is a two layer alternative.
Pogoprog is also a two layer board.</p>

<p>If you are building an Ubertooth One or Zero, you should also consider
building a Pogoprog unless you already have a plan for how you will <a
href="../program">program</a> your board.</p>

<h2>step 2: order a stencil</h2>

<p>Surface mount soldering is fun and easy if you use a stencil to apply solder
paste to your circuit board!  Send the top paste Gerber file
(ubertooth-one-SoldP_Front.gtp) to a stencil manufacturer such as <a
href="http://ohararp.com/Stencils.html">OHARARP</a> or <a
href="http://www.pololu.com/catalog/product/446">Pololu</a>.  Alternatively you
might plan to use a syringe or a toothpick to apply solder paste, but this is
not recommended.  You might instead just use a soldering iron, but this is
strongly discouraged unless you have successfully soldered QFNs with required
ground pads before (and, if you have, you probably aren't reading these
instructions anyway).</p>

<h2>step 3: order the parts</h2>

<p>Take the bill of materials (bom) from the most recent Project Ubertooth
release (or generate it with KiCad) and order the parts.  The parts should all
be available from one or more online electronics suppliers such as <a
href="http://www.mouser.com/">Mouser</a> and <a
href="http://www.digikey.com/">Digi-key</a>.  It is important to order some
extra parts (especially the tiny ones which fortunately are cheap) in case you
lose or damage any components.</p>

<p>You may want to order an antenna too.  The <a
href="http://www.pulseelectronics.com/products/antennas/products__solutions/antennas_for_wireless_devices/wd_antennas/w1030_external_24_ghz_high_gain_short">Pulse
W1030</a> is a nice size, but you can also find compatible antennas on many
commercial Wi-Fi and Bluetooth products.  Most any antenna intended for the 2.4
GHz band (such as 802.11b/g/n) is suitable as long as it has an RP-SMA
connector, adapter, or pigtail.  You could choose an SMA connector instead of
RP-SMA; this might especially be convenient for interfacing with benchtop test
gear.  RP-SMA was selected as the default choice for Project Ubertooth because
there are more RP-SMA than SMA antennas floating around on consumer Wi-Fi and
Bluetooth gear.</p>

<p>You might prefer to select alternative parts, but be careful of the 1%
resistors and all of the 0402 inductors and capacitors in the RF section which
have been selected for their particular characteristics.  Any LPC175x
microcontroller will do, but it is recommended that you choose one with at
least 128 kB RAM.  And, really, if you're going through all this trouble, why
not go with 512 kB?</p>

<h2>step 4: prepare your tools and materials</h2>

<p>essential:</p>

<ul>
	<li>an electric skillet, one that you don't intend to use for food ever again</li>
	<li>solder paste (no-clean lead-based solder paste is recommended)</li>
	<li>a small putty knife or razor blade</li>
	<li>fine tipped tweezers</li>
	<li>any old soldering iron</li>
	<li>solder</li>
</ul>

<p>strongly recommended:</p>

<ul>
	<li>good ventilation</li>
	<li>a temperature controlled soldering iron: this is more than just having
	a knob; it should have a temperature sensor in the iron</li>
	<li>an embossing tool or other high temperature heat gun (even better: a
	proper hot air rework station)</li>
	<li>a multitester with LED/diode test mode</li>
	<li>desoldering braid</li>
	<li>brass sponge</li>
	<li>helping hands</li>
	<li>magnifying glass</li>
</ul>

<h2>step 5: apply solder paste</h2>

<p>Using your stencil and a putty knife, apply the solder paste as described in
this <a href="http://www.sparkfun.com/tutorials/58">tutorial</a>.

<h2>step 6: place the parts</h2>

<p>With fine tipped tweezers, carefully place the parts on the board.  If you
have to move a part, pick it up and place it again rather than sliding it
around a lot.  Otherwise the paste can get out of place.  Most of the 0402 and
0603 parts can be placed in either direction, but the LEDs are exceptions.  You
must place them with ground in the direction of the arrow on the circuit board.
You may have to look at the design in KiCad to see which way the arrow goes,
and you'll probably have to test your LEDs with a multitester to find out which
side is which.  Don't populate USB connectors, RP-SMA connectors, or pogo pins
(in the case of Pogoprog) at this time.</p>

<h2>step 7: reflow</h2>

<p>Carefully place the board in the electric skillet, and turn the skillet on.
It is best to warm up the board to a moderate temperature before turning the
skillet up to full power.  Then turn up the heat until you can see the solder
flow.  If you see parts moving around to incorrect positions, resist the
temptation to correct them at this time!  As soon as the solder everywhere on
the board appears liquid, cut the power completely.  You may want to lift the
board out of the skillet with a spatula at this point to allow it to cool
faster.  There is a danger of overheating the components, but this is unlikely
unless you left the skillet on longer than necessary or used lead-free solder
paste.

<h2>step 7: rework</h2>

<p>Here is where the embossing tool, a good soldering iron, desoldering braid,
and a magnifying glass come in very handy.  If there is anything wrong with the
assembly, you will have to correct individual part placement as needed.</p>

<h2>step 8: inspection</h2>

<p>Once all the parts appear to be soldered in place correctly, look again,
this time with a magnifying glass.  You should also do some continuity tests
with a multitester at this point.  Watch out in particular for supply shorts;
the easiest way to test for these is to verify a lack of continuity across
bypass capacitors (all the caps that are close to the ICs).  If there is a
short that you can't see, it is probably under the pins of one of the ICs.
Repeat steps 7 and 8 as necessary.</p>

<h2>step 9: hand soldering</h2>

<p>There are a few parts that you should solder on by hand with an iron at this
point.  These are the USB and RP-SMA connectors on the Ubertooth boards and the
pogo pins on Pogoprog.</p>

<h2>step 10: power-on test</h2>

<p>Power on the device by plugging in the USB connection.  An Ubertooth One or
Zero should illuminate the RST LED.  If this doesn't happen, quickly unplug USB
verify that the LED is oriented correctly, and go back to step 8.  A Pogoprog
should flash its TX and RX LEDs during USB enumeration.  If this doesn't
happen, quickly unplug USB, verify the LED orientations, check your driver
situation, and go back to step 8.

<h2>step 11: further testing</h2>

<p>If you are building a Pogoprog, you should make sure that an FTDI USB serial
adapter has been detected by your host operating system.  If so, you can try
using it to <a href="../program">program</a> an Ubertooth board.  If you are
making an Ubertooth board, you should follow the procedure in
firmware/assembly_test/README.</p>

<h2>step 12: boast</h2>

<p>Tell us about your success on the <a
href="https://lists.sourceforge.net/lists/listinfo/ubertooth-general">ubertooth
general</a> mailing list.</p>

    </div>
    <div id="sidebar">
      <h1>Project Ubertooth</h1>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki">home</a></li>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/releases">download</a></li>
      </ul>
      <h2>usage</h2>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Getting-Started">getting started</a></li>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Build-Guide">build guide</a></li>
      </ul>
      <h2>hardware</h2>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Ubertooth-Zero">Ubertooth Zero</a></li>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Ubertooth-One">Ubertooth One</a></li>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Assembling-Hardware">build guide</a></li>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Programming">programming</a></li>
      </ul>
      <h2>firmware</h2>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Firmware">developing</a></li>
      </ul>
      <h2>host code</h2>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Software">developing</a></li>
      </ul>
      <h2>help</h2>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Getting-Help">Getting Help</a></li>
        <li><a href="https://lists.sourceforge.net/lists/listinfo/ubertooth-general">mailing list</a></li>
      </ul>
    </div>
  </body>
</html>
;T;	I"%<h1>Hardware Build Guide</h1>

<p>This describes the build process for Ubertooth One, but the processes for
Ubertooth Zero and Pogoprog are essentially the same.</p>

<h2>step 0: read these instructions</h2>

<p>Seriously.  There are probably things in the later steps that you should
know about before getting started.</p>

<h2>step 1: order a PCB</h2>

<p>You will need a four layer printed circuit board.  I recommend using Laen's
PCB service at <a href="http://dorkbotpdx.org/wiki/pcb_order">DorkbotPDX</a>.
Take the Ubertooth One Gerber files from the most recent Project Ubertooth
release package (or generate them with KiCad) and send them to Laen.  The board
is 1.8 square inches, so it will cost $18 per set of three.  That's one for
yourself, one for a friend, and one to screw up!  If you live on Mars and can't
get a four layer board manufactured, Ubertooth Zero is a two layer alternative.
Pogoprog is also a two layer board.</p>

<p>If you are building an Ubertooth One or Zero, you should also consider
building a Pogoprog unless you already have a plan for how you will <a
href="../program">program</a> your board.</p>

<h2>step 2: order a stencil</h2>

<p>Surface mount soldering is fun and easy if you use a stencil to apply solder
paste to your circuit board!  Send the top paste Gerber file
(ubertooth-one-SoldP_Front.gtp) to a stencil manufacturer such as <a
href="http://ohararp.com/Stencils.html">OHARARP</a> or <a
href="http://www.pololu.com/catalog/product/446">Pololu</a>.  Alternatively you
might plan to use a syringe or a toothpick to apply solder paste, but this is
not recommended.  You might instead just use a soldering iron, but this is
strongly discouraged unless you have successfully soldered QFNs with required
ground pads before (and, if you have, you probably aren't reading these
instructions anyway).</p>

<h2>step 3: order the parts</h2>

<p>Take the bill of materials (bom) from the most recent Project Ubertooth
release (or generate it with KiCad) and order the parts.  The parts should all
be available from one or more online electronics suppliers such as <a
href="http://www.mouser.com/">Mouser</a> and <a
href="http://www.digikey.com/">Digi-key</a>.  It is important to order some
extra parts (especially the tiny ones which fortunately are cheap) in case you
lose or damage any components.</p>

<p>You may want to order an antenna too.  The <a
href="http://www.pulseelectronics.com/products/antennas/products__solutions/antennas_for_wireless_devices/wd_antennas/w1030_external_24_ghz_high_gain_short">Pulse
W1030</a> is a nice size, but you can also find compatible antennas on many
commercial Wi-Fi and Bluetooth products.  Most any antenna intended for the 2.4
GHz band (such as 802.11b/g/n) is suitable as long as it has an RP-SMA
connector, adapter, or pigtail.  You could choose an SMA connector instead of
RP-SMA; this might especially be convenient for interfacing with benchtop test
gear.  RP-SMA was selected as the default choice for Project Ubertooth because
there are more RP-SMA than SMA antennas floating around on consumer Wi-Fi and
Bluetooth gear.</p>

<p>You might prefer to select alternative parts, but be careful of the 1%
resistors and all of the 0402 inductors and capacitors in the RF section which
have been selected for their particular characteristics.  Any LPC175x
microcontroller will do, but it is recommended that you choose one with at
least 128 kB RAM.  And, really, if you're going through all this trouble, why
not go with 512 kB?</p>

<h2>step 4: prepare your tools and materials</h2>

<p>essential:</p>

<ul>
	<li>an electric skillet, one that you don't intend to use for food ever again</li>
	<li>solder paste (no-clean lead-based solder paste is recommended)</li>
	<li>a small putty knife or razor blade</li>
	<li>fine tipped tweezers</li>
	<li>any old soldering iron</li>
	<li>solder</li>
</ul>

<p>strongly recommended:</p>

<ul>
	<li>good ventilation</li>
	<li>a temperature controlled soldering iron: this is more than just having
	a knob; it should have a temperature sensor in the iron</li>
	<li>an embossing tool or other high temperature heat gun (even better: a
	proper hot air rework station)</li>
	<li>a multitester with LED/diode test mode</li>
	<li>desoldering braid</li>
	<li>brass sponge</li>
	<li>helping hands</li>
	<li>magnifying glass</li>
</ul>

<h2>step 5: apply solder paste</h2>

<p>Using your stencil and a putty knife, apply the solder paste as described in
this <a href="http://www.sparkfun.com/tutorials/58">tutorial</a>.

<h2>step 6: place the parts</h2>

<p>With fine tipped tweezers, carefully place the parts on the board.  If you
have to move a part, pick it up and place it again rather than sliding it
around a lot.  Otherwise the paste can get out of place.  Most of the 0402 and
0603 parts can be placed in either direction, but the LEDs are exceptions.  You
must place them with ground in the direction of the arrow on the circuit board.
You may have to look at the design in KiCad to see which way the arrow goes,
and you'll probably have to test your LEDs with a multitester to find out which
side is which.  Don't populate USB connectors, RP-SMA connectors, or pogo pins
(in the case of Pogoprog) at this time.</p>

<h2>step 7: reflow</h2>

<p>Carefully place the board in the electric skillet, and turn the skillet on.
It is best to warm up the board to a moderate temperature before turning the
skillet up to full power.  Then turn up the heat until you can see the solder
flow.  If you see parts moving around to incorrect positions, resist the
temptation to correct them at this time!  As soon as the solder everywhere on
the board appears liquid, cut the power completely.  You may want to lift the
board out of the skillet with a spatula at this point to allow it to cool
faster.  There is a danger of overheating the components, but this is unlikely
unless you left the skillet on longer than necessary or used lead-free solder
paste.

<h2>step 7: rework</h2>

<p>Here is where the embossing tool, a good soldering iron, desoldering braid,
and a magnifying glass come in very handy.  If there is anything wrong with the
assembly, you will have to correct individual part placement as needed.</p>

<h2>step 8: inspection</h2>

<p>Once all the parts appear to be soldered in place correctly, look again,
this time with a magnifying glass.  You should also do some continuity tests
with a multitester at this point.  Watch out in particular for supply shorts;
the easiest way to test for these is to verify a lack of continuity across
bypass capacitors (all the caps that are close to the ICs).  If there is a
short that you can't see, it is probably under the pins of one of the ICs.
Repeat steps 7 and 8 as necessary.</p>

<h2>step 9: hand soldering</h2>

<p>There are a few parts that you should solder on by hand with an iron at this
point.  These are the USB and RP-SMA connectors on the Ubertooth boards and the
pogo pins on Pogoprog.</p>

<h2>step 10: power-on test</h2>

<p>Power on the device by plugging in the USB connection.  An Ubertooth One or
Zero should illuminate the RST LED.  If this doesn't happen, quickly unplug USB
verify that the LED is oriented correctly, and go back to step 8.  A Pogoprog
should flash its TX and RX LEDs during USB enumeration.  If this doesn't
happen, quickly unplug USB, verify the LED orientations, check your driver
situation, and go back to step 8.

<h2>step 11: further testing</h2>

<p>If you are building a Pogoprog, you should make sure that an FTDI USB serial
adapter has been detected by your host operating system.  If so, you can try
using it to <a href="../program">program</a> an Ubertooth board.  If you are
making an Ubertooth board, you should follow the procedure in
firmware/assembly_test/README.</p>

<h2>step 12: boast</h2>

<p>Tell us about your success on the <a
href="https://lists.sourceforge.net/lists/listinfo/ubertooth-general">ubertooth
general</a> mailing list.</p>
;T;
I"%<h1>Hardware Build Guide</h1>

<p>This describes the build process for Ubertooth One, but the processes for
Ubertooth Zero and Pogoprog are essentially the same.</p>

<h2>step 0: read these instructions</h2>

<p>Seriously.  There are probably things in the later steps that you should
know about before getting started.</p>

<h2>step 1: order a PCB</h2>

<p>You will need a four layer printed circuit board.  I recommend using Laen's
PCB service at <a href="http://dorkbotpdx.org/wiki/pcb_order">DorkbotPDX</a>.
Take the Ubertooth One Gerber files from the most recent Project Ubertooth
release package (or generate them with KiCad) and send them to Laen.  The board
is 1.8 square inches, so it will cost $18 per set of three.  That's one for
yourself, one for a friend, and one to screw up!  If you live on Mars and can't
get a four layer board manufactured, Ubertooth Zero is a two layer alternative.
Pogoprog is also a two layer board.</p>

<p>If you are building an Ubertooth One or Zero, you should also consider
building a Pogoprog unless you already have a plan for how you will <a
href="../program">program</a> your board.</p>

<h2>step 2: order a stencil</h2>

<p>Surface mount soldering is fun and easy if you use a stencil to apply solder
paste to your circuit board!  Send the top paste Gerber file
(ubertooth-one-SoldP_Front.gtp) to a stencil manufacturer such as <a
href="http://ohararp.com/Stencils.html">OHARARP</a> or <a
href="http://www.pololu.com/catalog/product/446">Pololu</a>.  Alternatively you
might plan to use a syringe or a toothpick to apply solder paste, but this is
not recommended.  You might instead just use a soldering iron, but this is
strongly discouraged unless you have successfully soldered QFNs with required
ground pads before (and, if you have, you probably aren't reading these
instructions anyway).</p>

<h2>step 3: order the parts</h2>

<p>Take the bill of materials (bom) from the most recent Project Ubertooth
release (or generate it with KiCad) and order the parts.  The parts should all
be available from one or more online electronics suppliers such as <a
href="http://www.mouser.com/">Mouser</a> and <a
href="http://www.digikey.com/">Digi-key</a>.  It is important to order some
extra parts (especially the tiny ones which fortunately are cheap) in case you
lose or damage any components.</p>

<p>You may want to order an antenna too.  The <a
href="http://www.pulseelectronics.com/products/antennas/products__solutions/antennas_for_wireless_devices/wd_antennas/w1030_external_24_ghz_high_gain_short">Pulse
W1030</a> is a nice size, but you can also find compatible antennas on many
commercial Wi-Fi and Bluetooth products.  Most any antenna intended for the 2.4
GHz band (such as 802.11b/g/n) is suitable as long as it has an RP-SMA
connector, adapter, or pigtail.  You could choose an SMA connector instead of
RP-SMA; this might especially be convenient for interfacing with benchtop test
gear.  RP-SMA was selected as the default choice for Project Ubertooth because
there are more RP-SMA than SMA antennas floating around on consumer Wi-Fi and
Bluetooth gear.</p>

<p>You might prefer to select alternative parts, but be careful of the 1%
resistors and all of the 0402 inductors and capacitors in the RF section which
have been selected for their particular characteristics.  Any LPC175x
microcontroller will do, but it is recommended that you choose one with at
least 128 kB RAM.  And, really, if you're going through all this trouble, why
not go with 512 kB?</p>

<h2>step 4: prepare your tools and materials</h2>

<p>essential:</p>

<ul>
	<li>an electric skillet, one that you don't intend to use for food ever again</li>
	<li>solder paste (no-clean lead-based solder paste is recommended)</li>
	<li>a small putty knife or razor blade</li>
	<li>fine tipped tweezers</li>
	<li>any old soldering iron</li>
	<li>solder</li>
</ul>

<p>strongly recommended:</p>

<ul>
	<li>good ventilation</li>
	<li>a temperature controlled soldering iron: this is more than just having
	a knob; it should have a temperature sensor in the iron</li>
	<li>an embossing tool or other high temperature heat gun (even better: a
	proper hot air rework station)</li>
	<li>a multitester with LED/diode test mode</li>
	<li>desoldering braid</li>
	<li>brass sponge</li>
	<li>helping hands</li>
	<li>magnifying glass</li>
</ul>

<h2>step 5: apply solder paste</h2>

<p>Using your stencil and a putty knife, apply the solder paste as described in
this <a href="http://www.sparkfun.com/tutorials/58">tutorial</a>.

<h2>step 6: place the parts</h2>

<p>With fine tipped tweezers, carefully place the parts on the board.  If you
have to move a part, pick it up and place it again rather than sliding it
around a lot.  Otherwise the paste can get out of place.  Most of the 0402 and
0603 parts can be placed in either direction, but the LEDs are exceptions.  You
must place them with ground in the direction of the arrow on the circuit board.
You may have to look at the design in KiCad to see which way the arrow goes,
and you'll probably have to test your LEDs with a multitester to find out which
side is which.  Don't populate USB connectors, RP-SMA connectors, or pogo pins
(in the case of Pogoprog) at this time.</p>

<h2>step 7: reflow</h2>

<p>Carefully place the board in the electric skillet, and turn the skillet on.
It is best to warm up the board to a moderate temperature before turning the
skillet up to full power.  Then turn up the heat until you can see the solder
flow.  If you see parts moving around to incorrect positions, resist the
temptation to correct them at this time!  As soon as the solder everywhere on
the board appears liquid, cut the power completely.  You may want to lift the
board out of the skillet with a spatula at this point to allow it to cool
faster.  There is a danger of overheating the components, but this is unlikely
unless you left the skillet on longer than necessary or used lead-free solder
paste.

<h2>step 7: rework</h2>

<p>Here is where the embossing tool, a good soldering iron, desoldering braid,
and a magnifying glass come in very handy.  If there is anything wrong with the
assembly, you will have to correct individual part placement as needed.</p>

<h2>step 8: inspection</h2>

<p>Once all the parts appear to be soldered in place correctly, look again,
this time with a magnifying glass.  You should also do some continuity tests
with a multitester at this point.  Watch out in particular for supply shorts;
the easiest way to test for these is to verify a lack of continuity across
bypass capacitors (all the caps that are close to the ICs).  If there is a
short that you can't see, it is probably under the pins of one of the ICs.
Repeat steps 7 and 8 as necessary.</p>

<h2>step 9: hand soldering</h2>

<p>There are a few parts that you should solder on by hand with an iron at this
point.  These are the USB and RP-SMA connectors on the Ubertooth boards and the
pogo pins on Pogoprog.</p>

<h2>step 10: power-on test</h2>

<p>Power on the device by plugging in the USB connection.  An Ubertooth One or
Zero should illuminate the RST LED.  If this doesn't happen, quickly unplug USB
verify that the LED is oriented correctly, and go back to step 8.  A Pogoprog
should flash its TX and RX LEDs during USB enumeration.  If this doesn't
happen, quickly unplug USB, verify the LED orientations, check your driver
situation, and go back to step 8.

<h2>step 11: further testing</h2>

<p>If you are building a Pogoprog, you should make sure that an FTDI USB serial
adapter has been detected by your host operating system.  If so, you can try
using it to <a href="../program">program</a> an Ubertooth board.  If you are
making an Ubertooth board, you should follow the procedure in
firmware/assembly_test/README.</p>

<h2>step 12: boast</h2>

<p>Tell us about your success on the <a
href="https://lists.sourceforge.net/lists/listinfo/ubertooth-general">ubertooth
general</a> mailing list.</p>
;T;@I"/host/develop/;T{;{	;I"©	<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Project Ubertooth - Developing Host Code</title>
    <link rel="stylesheet" type="text/css" href="/style.css" media="screen">
    <meta name="generator" content="nanoc 3.1.6">
  </head>
  <body>
    <div id="main">
      <h1>Developing Host Code</h1>

<p>Host code is the software running on a host computer to which an Ubertooth
One or Ubertooth Zero is attached via USB.</p>

<p>The Ubertooth developers use GCC on Linux.  Theoretically, host code could
be written on or for other platforms, but it hasn't been done yet.</p>

<p>Although source can be found in the 
<a href="https://github.com/greatscottgadgets/ubertooth/releases">release downloads</a>, 
you will probably want fresh code from <a
href="http://www.github.com/greatscottgadgets/ubertooth">git</a>.</p>

    </div>
    <div id="sidebar">
      <h1>Project Ubertooth</h1>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki">home</a></li>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/releases">download</a></li>
      </ul>
      <h2>usage</h2>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Getting-Started">getting started</a></li>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Build-Guide">build guide</a></li>
      </ul>
      <h2>hardware</h2>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Ubertooth-Zero">Ubertooth Zero</a></li>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Ubertooth-One">Ubertooth One</a></li>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Assembling-Hardware">build guide</a></li>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Programming">programming</a></li>
      </ul>
      <h2>firmware</h2>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Firmware">developing</a></li>
      </ul>
      <h2>host code</h2>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Software">developing</a></li>
      </ul>
      <h2>help</h2>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Getting-Help">Getting Help</a></li>
        <li><a href="https://lists.sourceforge.net/lists/listinfo/ubertooth-general">mailing list</a></li>
      </ul>
    </div>
  </body>
</html>
;T;	I"%<h1>Developing Host Code</h1>

<p>Host code is the software running on a host computer to which an Ubertooth
One or Ubertooth Zero is attached via USB.</p>

<p>The Ubertooth developers use GCC on Linux.  Theoretically, host code could
be written on or for other platforms, but it hasn't been done yet.</p>

<p>Although source can be found in the 
<a href="https://github.com/greatscottgadgets/ubertooth/releases">release downloads</a>, 
you will probably want fresh code from <a
href="http://www.github.com/greatscottgadgets/ubertooth">git</a>.</p>
;T;
I"%<h1>Developing Host Code</h1>

<p>Host code is the software running on a host computer to which an Ubertooth
One or Ubertooth Zero is attached via USB.</p>

<p>The Ubertooth developers use GCC on Linux.  Theoretically, host code could
be written on or for other platforms, but it hasn't been done yet.</p>

<p>Although source can be found in the 
<a href="https://github.com/greatscottgadgets/ubertooth/releases">release downloads</a>, 
you will probably want fresh code from <a
href="http://www.github.com/greatscottgadgets/ubertooth">git</a>.</p>
;T;@"I"/;T{;{	;I"Q
<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Project Ubertooth - Home</title>
    <link rel="stylesheet" type="text/css" href="/style.css" media="screen">
    <meta name="generator" content="nanoc 3.1.6">
  </head>
  <body>
    <div id="main">
      <h1>Project Ubertooth</h1>

<p><em>An open source 2.4 GHz wireless development platform suitable for
Bluetooth experimentation</em></p>

<p>Ubertooth has now moved to <a
href="https://github.com/greatscottgadgets/ubertooth/">GitHub</a>. You may
follow the links below to find up to date information about the project.</p>

<ul>
	<li>Our open source hardware, software and firmware is available from our 
	<a href="https://github.com/greatscottgadgets/ubertooth/">git repository</a>.</li>
	<li>Documentation can be found on the 
	<a href="https://github.com/greatscottgadgets/ubertooth/wiki">wiki</a>.</li>
	<li>A list of Ubertooth One
	<a href="http://greatscottgadgets.com/ubertoothone/">resellers</a> is also available.</li>
</ul>

    </div>
    <div id="sidebar">
      <h1>Project Ubertooth</h1>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki">home</a></li>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/releases">download</a></li>
      </ul>
      <h2>usage</h2>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Getting-Started">getting started</a></li>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Build-Guide">build guide</a></li>
      </ul>
      <h2>hardware</h2>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Ubertooth-Zero">Ubertooth Zero</a></li>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Ubertooth-One">Ubertooth One</a></li>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Assembling-Hardware">build guide</a></li>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Programming">programming</a></li>
      </ul>
      <h2>firmware</h2>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Firmware">developing</a></li>
      </ul>
      <h2>host code</h2>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Software">developing</a></li>
      </ul>
      <h2>help</h2>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Getting-Help">Getting Help</a></li>
        <li><a href="https://lists.sourceforge.net/lists/listinfo/ubertooth-general">mailing list</a></li>
      </ul>
    </div>
  </body>
</html>
;T;	I"Ý<h1>Project Ubertooth</h1>

<p><em>An open source 2.4 GHz wireless development platform suitable for
Bluetooth experimentation</em></p>

<p>Ubertooth has now moved to <a
href="https://github.com/greatscottgadgets/ubertooth/">GitHub</a>. You may
follow the links below to find up to date information about the project.</p>

<ul>
	<li>Our open source hardware, software and firmware is available from our 
	<a href="https://github.com/greatscottgadgets/ubertooth/">git repository</a>.</li>
	<li>Documentation can be found on the 
	<a href="https://github.com/greatscottgadgets/ubertooth/wiki">wiki</a>.</li>
	<li>A list of Ubertooth One
	<a href="http://greatscottgadgets.com/ubertoothone/">resellers</a> is also available.</li>
</ul>
;T;
I"Ý<h1>Project Ubertooth</h1>

<p><em>An open source 2.4 GHz wireless development platform suitable for
Bluetooth experimentation</em></p>

<p>Ubertooth has now moved to <a
href="https://github.com/greatscottgadgets/ubertooth/">GitHub</a>. You may
follow the links below to find up to date information about the project.</p>

<ul>
	<li>Our open source hardware, software and firmware is available from our 
	<a href="https://github.com/greatscottgadgets/ubertooth/">git repository</a>.</li>
	<li>Documentation can be found on the 
	<a href="https://github.com/greatscottgadgets/ubertooth/wiki">wiki</a>.</li>
	<li>A list of Ubertooth One
	<a href="http://greatscottgadgets.com/ubertoothone/">resellers</a> is also available.</li>
</ul>
;T;@(I" /images/ubertooth-one-zero/;T{;{ I"/images/kismet/;T{;{ I"/images/pogoprog/;T{;{ I"/images/u1_roadmap/;T{;{ I"/images/ubertooth-zero/;T{;{ I"/images/ubertooth-lap/;T{;{ I"/images/ubertooth-one/;T{;{ I" /images/pogoprog-placement/;T{;{ I"/images/specan_ui/;T{;{ I"/stylesheet/;T{;{;I"ñ* {
  margin: 0;
  padding: 0;

  font-family: Palatino, 'Times New Roman', Times, serif;
}

body {
  background: #fff;
}

a {
  text-decoration: inherit;
  font-family: inherit;
}

a:link,
a:visited {
  color: #30f;
}

a:hover {
  color: #39f;
}

a[name]:hover {
  color: inherit;
}

#main {
  position: absolute;

  top: 40px;
  left: 280px;

  width: 500px;
}

#main h1 {
  font-size: 40px;
  font-weight: normal;

  line-height: 40px;

  letter-spacing: -1px;
  font-family: Impact, Helvetica, Arial, sans-serif;
}

#main h2,h3,h4 {
  font-family: 'Courier New', Courier, monospace;
}

#main p {
  margin: 20px 0;
  
  font-size: 15px;
  
  line-height: 20px;
}

#main ul {
  margin: 20px;
}

#main li {
  list-style-type: square;

  font-size: 15px;
  
  line-height: 20px;
}

#main img {
  margin: 20px 0;
}

#sidebar {
  position: absolute;

  top: 40px;
  left: 20px;
  width: 200px;

  padding: 20px 20px 0 0;

  border-right: 1px solid #ccc;

  text-align: right;
}

#sidebar h1 {
  font-family: 'Courier New', Courier, monospace;
}
#sidebar h2 {

  font-size: 18px;

  color: #333;

  letter-spacing: 1px;

  line-height: 20px;
  font-family: 'Courier New', Courier, monospace;
}

#sidebar ul {
  list-style-type: none;

  margin: 20px 0;
}

#sidebar li {
  font-size: 14px;

  line-height: 20px;
}

pre,
pre a {
  /*margin: 1em 1em 1em 1.6em;*/
  font-family: 'Courier New', Courier, monospace;
  font-size: small;
  padding: 2px 2px 2px 0;
  /*background-color: #FAFAFA;*/
  /*border: 1px solid #DADADA;*/
}
;T;	@I;
@II"/usage/start/;T{;{	;I"þ(<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Project Ubertooth - Getting Started</title>
    <link rel="stylesheet" type="text/css" href="/style.css" media="screen">
    <meta name="generator" content="nanoc 3.1.6">
  </head>
  <body>
    <div id="main">
      
<h1>Getting Started</h1>

<p>There are three major components of Project Ubertooth:</p>

<ul>
	<li>hardware: The hardware design of Ubertooth One is quite stable. You can
	<a href="../../hardware/build">build</a> one or <a
	href="http://greatscottgadgets.com/">buy</a> one.</li>
	<li>firmware: This is software that executes on the ARM processor on the
	Ubertooth One itself.  This page assumes that you have the USB bootloader
	plus bluetooth_rxtx firmware installed on your board (which is typically
	what is installed at the time of assembly). The bluetooth_rxtx firmware is
	moderately stable but is likely to be enhanced as time goes on.</li>
	<li>host code: This is software running on a general purpose computer
	connected to the Ubertooth One via USB. The sample host code for Project
	Ubertooth is in active development and will likely change a great deal in
	the coming months. If you have not yet built the host code, please follow
	the <a href=../build>build guide</a>.</li>
</ul>

<p>Ubertooth One is a development platform. The true power of the device is
best realized when you start writing your own software and adapting it to your
needs. If you are just getting to know the board, however, it can be helpful to
try out open source code that others have made available. This guide will help
you get started with your Ubertooth One by introducing you to some useful host
code from the Ubertooth software repository.</p>

<h2>Spectrum Analysis</h2>

<img src="../../images/specan_ui.png" alt="spectrum analyzer screenshot" />

<p>The first thing you should try with a new Ubertooth One is real-time
spectrum analysis. Take a look at Jared's <a
href="http://www.sharebrained.com/2011/05/24/ubertooth-spectrum-analysis-fun/">demonstration
video</a> for a preview.</p>

<p>Connect an antenna to your Ubertooth One and plug it into your computer.
(Never operate your Ubertooth One without an antenna connected.) You should see
the RST and 1V8 LEDs illuminate. This indicates that the LPC175x
microcontroller is running (RST) and that power is being supplied to the CC2400
wireless transceiver IC (1V8). The USB LED may also light up if your computer's
operating system has enumerated and configured the device (typical on Linux).
Now you need some host code to tell the Ubertooth One what to do.</p>

<p><a href="http://sourceforge.net/projects/ubertooth/">Download</a> the latest
Project Ubertooth file release or check out current development code from the
<a href="http://sourceforge.net/projects/ubertooth/develop">svn repository</a>
and navigate to the host/specan_ui directory. Take a look at the README file
and make sure that you have installed the prerequisite software. Then execute
ubertooth-specan-ui as described in the README and watch the 2.4 GHz activity
detected by the Ubertooth One.</p>

<p>One possible thing that could go wrong at this point is that your operating
system does not grant you permission to communicate with the USB device.
Depending on your distribution and preference, this can be fixed on Linux
either by adding your user account to the &quot;usb&quot; group or by creating
a new udev rule such as:</p>

<code>$ echo 'ACTION==&quot;add&quot; BUS==&quot;usb&quot; SYSFS{idVendor}==&quot;ffff&quot;
SYSFS{idProduct}==&quot;0004&quot; GROUP:=&quot;plugdev&quot; MODE:=&quot;0660&quot;' &gt;
/etc/udev/rules.d/99-ubertooth.rules</code>

<p>A udev rules file is available in host/bluetooth_rxtx directory in both svn
and the release packages.  Copy it to /etc/udev/rules.d and run the
following as root:</p>

<code>udevadm control --reload-rules</code>

<p>Make sure you are a member of the &quot;plugdev&quot; group or change the
rule to refer to the group of your choice.  After adding the udev rule, unplug
the Ubertooth One, reboot or restart udevd, and plug in the Ubertooth One
again.</p>

<p>During operation of ubertooth-specan-ui the RX LED should illuminate, and
the USR LED should be dimly lit. After you finish trying out
ubertooth-specan-ui reset your Ubertooth One by unplugging it and plugging it
back in.</p>

<h2>LAP Sniffing</h2>

<img src="../../images/ubertooth-lap.png" alt="ubertooth-lap screenshot" />

<p>Bluetooth packets start with a code that is based on the Lower Address Part
(LAP) of a particular Bluetooth Device Address (BD_ADDR). The BD_ADDR is a 48
bit MAC address, just like the MAC address of an Ethernet device. The LAP
consists of the lower 24 bits of the BD_ADDR and is the only part of the
address that is transmitted with every packet.</p>

<p>The most important passive Bluetooth monitoring function is simply capturing
the LAP from each packet transmitted on a channel. LAP sniffing allows you to
identify Bluetooth devices operating in your vicinity.</p>

<p>In order to sniff LAPs, you'll have to compile the tools in
host/bluetooth_rxtx. These are command line programs intended to work with the
bluetooth_rxtx firmware installed on your Ubertooth One. Follow the
instructions in the README file in that directory to install the the
prerequisite <a href="http://libbtbb.sourceforge.net/">libbtbb</a>, a library
for Bluetooth baseband functions. You can install libbtbb from a <a
href="http://sourceforge.net/projects/libbtbb/files/">file release</a> rather
than git if you prefer.</p>

<p>Once libbtbb is installed, just type &quot;make&quot; in the
host/bluetooth_rxtx directory to compile the tools there. Then make sure your
Ubertooth One is plugged in and execute:</p>

<code>$ ubertooth-rx</code>

<p>You should see various random LAPs detected. Due to uncertainties in
identifying Bluetooth packets without prior knowledge of an address, it is
normal for this process to identify false positives. error correction should
mitigate this problem, but a small number of false positives may still be seen.
When you see the same LAP detected more than once, that is very likely an actual
Bluetooth transmission.</p>

<p>Generate some Bluetooth traffic and enjoy the show. I like to use a mobile
phone or other Bluetooth device to perform an inquiry (usually called
&quot;find new Bluetooth devices&quot; or something similar) to make sure that
everything is working properly. An inquiry should produce lots of packets with
the LAP 0x9e8b33.</p>

<p>Once you have seen a LAP multiple times, you can be confident that it is a
genuine Bluetooth piconet. To find the next byte of the address, the UAP, we
can use:</p>

<code>$ ubertooth-rx -l [LAP]</code>

<p>In this mode ubertooth-rx only detects packets from the given piconet and
uses them to determine the next byte of the address and some of the internal
clock value.</p>

<p>For more information on this process, and the challenges involved in 
monitoring Bluetooth connections, please read this 
<a href="http://ubertooth.blogspot.co.uk/2013/02/motivating-problem.html">blog 
post</a>
<h2>Kismet</h2>

<img src="../../images/kismet.png" alt="Kismet-Ubertooth screenshot" />

<p>More advanced Bluetooth sniffing has been implemented in the form of a
plugin for <a href="http://www.kismetwireless.net/">Kismet</a>, the venerable
802.11 monitoring tool. In order to compile the Kismet-Ubertooth plugin, you
will need a Kismet source tree matching the installed version. The easiest way
to make this work is to uninstall any binary Kismet installation you may have
installed and then download the Kismet source and follow the instructions to
compile and install from the fresh source code. Once Kismet is installed,
follow the instructions in host/kismet/plugin-ubertooth/README to install and
use the plugin.</p>

<p>Notice that Kismet-Ubertooth identifies not only the LAP but also the 8 bit
Upper Address Part (UAP) of detected devices as it is able. This is done by
analyzing the timing and other characteristics of multiple packets over time.
Another advantage of Kismet is that it dumps complete decoded packets to a
pcapbtbb file that can be read with a Wireshark plugin that is distributed with
<a href="http://libbtbb.sourceforge.net/">libbtbb</a>. Full packet decoding is
only possible when the packet's UAP has been determined.</p>

<h2>Where to Go from Here</h2>

<p>I hope you have found this guide helpful in getting to know your Ubertooth
One. The host code for Project Ubertooth is in active development and new
features are being worked on all the time. If you are interested in
contributing to the project, or if you need help or would just like to chat
about Project Ubertooth, join the <a
href="https://lists.sourceforge.net/lists/listinfo/ubertooth-general">ubertooth-general</a>
mailing list. Happy hacking!</p>

    </div>
    <div id="sidebar">
      <h1>Project Ubertooth</h1>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki">home</a></li>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/releases">download</a></li>
      </ul>
      <h2>usage</h2>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Getting-Started">getting started</a></li>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Build-Guide">build guide</a></li>
      </ul>
      <h2>hardware</h2>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Ubertooth-Zero">Ubertooth Zero</a></li>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Ubertooth-One">Ubertooth One</a></li>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Assembling-Hardware">build guide</a></li>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Programming">programming</a></li>
      </ul>
      <h2>firmware</h2>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Firmware">developing</a></li>
      </ul>
      <h2>host code</h2>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Software">developing</a></li>
      </ul>
      <h2>help</h2>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Getting-Help">Getting Help</a></li>
        <li><a href="https://lists.sourceforge.net/lists/listinfo/ubertooth-general">mailing list</a></li>
      </ul>
    </div>
  </body>
</html>
;T;	I"!
<h1>Getting Started</h1>

<p>There are three major components of Project Ubertooth:</p>

<ul>
	<li>hardware: The hardware design of Ubertooth One is quite stable. You can
	<a href="../../hardware/build">build</a> one or <a
	href="http://greatscottgadgets.com/">buy</a> one.</li>
	<li>firmware: This is software that executes on the ARM processor on the
	Ubertooth One itself.  This page assumes that you have the USB bootloader
	plus bluetooth_rxtx firmware installed on your board (which is typically
	what is installed at the time of assembly). The bluetooth_rxtx firmware is
	moderately stable but is likely to be enhanced as time goes on.</li>
	<li>host code: This is software running on a general purpose computer
	connected to the Ubertooth One via USB. The sample host code for Project
	Ubertooth is in active development and will likely change a great deal in
	the coming months. If you have not yet built the host code, please follow
	the <a href=../build>build guide</a>.</li>
</ul>

<p>Ubertooth One is a development platform. The true power of the device is
best realized when you start writing your own software and adapting it to your
needs. If you are just getting to know the board, however, it can be helpful to
try out open source code that others have made available. This guide will help
you get started with your Ubertooth One by introducing you to some useful host
code from the Ubertooth software repository.</p>

<h2>Spectrum Analysis</h2>

<img src="../../images/specan_ui.png" alt="spectrum analyzer screenshot" />

<p>The first thing you should try with a new Ubertooth One is real-time
spectrum analysis. Take a look at Jared's <a
href="http://www.sharebrained.com/2011/05/24/ubertooth-spectrum-analysis-fun/">demonstration
video</a> for a preview.</p>

<p>Connect an antenna to your Ubertooth One and plug it into your computer.
(Never operate your Ubertooth One without an antenna connected.) You should see
the RST and 1V8 LEDs illuminate. This indicates that the LPC175x
microcontroller is running (RST) and that power is being supplied to the CC2400
wireless transceiver IC (1V8). The USB LED may also light up if your computer's
operating system has enumerated and configured the device (typical on Linux).
Now you need some host code to tell the Ubertooth One what to do.</p>

<p><a href="http://sourceforge.net/projects/ubertooth/">Download</a> the latest
Project Ubertooth file release or check out current development code from the
<a href="http://sourceforge.net/projects/ubertooth/develop">svn repository</a>
and navigate to the host/specan_ui directory. Take a look at the README file
and make sure that you have installed the prerequisite software. Then execute
ubertooth-specan-ui as described in the README and watch the 2.4 GHz activity
detected by the Ubertooth One.</p>

<p>One possible thing that could go wrong at this point is that your operating
system does not grant you permission to communicate with the USB device.
Depending on your distribution and preference, this can be fixed on Linux
either by adding your user account to the &quot;usb&quot; group or by creating
a new udev rule such as:</p>

<code>$ echo 'ACTION==&quot;add&quot; BUS==&quot;usb&quot; SYSFS{idVendor}==&quot;ffff&quot;
SYSFS{idProduct}==&quot;0004&quot; GROUP:=&quot;plugdev&quot; MODE:=&quot;0660&quot;' &gt;
/etc/udev/rules.d/99-ubertooth.rules</code>

<p>A udev rules file is available in host/bluetooth_rxtx directory in both svn
and the release packages.  Copy it to /etc/udev/rules.d and run the
following as root:</p>

<code>udevadm control --reload-rules</code>

<p>Make sure you are a member of the &quot;plugdev&quot; group or change the
rule to refer to the group of your choice.  After adding the udev rule, unplug
the Ubertooth One, reboot or restart udevd, and plug in the Ubertooth One
again.</p>

<p>During operation of ubertooth-specan-ui the RX LED should illuminate, and
the USR LED should be dimly lit. After you finish trying out
ubertooth-specan-ui reset your Ubertooth One by unplugging it and plugging it
back in.</p>

<h2>LAP Sniffing</h2>

<img src="../../images/ubertooth-lap.png" alt="ubertooth-lap screenshot" />

<p>Bluetooth packets start with a code that is based on the Lower Address Part
(LAP) of a particular Bluetooth Device Address (BD_ADDR). The BD_ADDR is a 48
bit MAC address, just like the MAC address of an Ethernet device. The LAP
consists of the lower 24 bits of the BD_ADDR and is the only part of the
address that is transmitted with every packet.</p>

<p>The most important passive Bluetooth monitoring function is simply capturing
the LAP from each packet transmitted on a channel. LAP sniffing allows you to
identify Bluetooth devices operating in your vicinity.</p>

<p>In order to sniff LAPs, you'll have to compile the tools in
host/bluetooth_rxtx. These are command line programs intended to work with the
bluetooth_rxtx firmware installed on your Ubertooth One. Follow the
instructions in the README file in that directory to install the the
prerequisite <a href="http://libbtbb.sourceforge.net/">libbtbb</a>, a library
for Bluetooth baseband functions. You can install libbtbb from a <a
href="http://sourceforge.net/projects/libbtbb/files/">file release</a> rather
than git if you prefer.</p>

<p>Once libbtbb is installed, just type &quot;make&quot; in the
host/bluetooth_rxtx directory to compile the tools there. Then make sure your
Ubertooth One is plugged in and execute:</p>

<code>$ ubertooth-rx</code>

<p>You should see various random LAPs detected. Due to uncertainties in
identifying Bluetooth packets without prior knowledge of an address, it is
normal for this process to identify false positives. error correction should
mitigate this problem, but a small number of false positives may still be seen.
When you see the same LAP detected more than once, that is very likely an actual
Bluetooth transmission.</p>

<p>Generate some Bluetooth traffic and enjoy the show. I like to use a mobile
phone or other Bluetooth device to perform an inquiry (usually called
&quot;find new Bluetooth devices&quot; or something similar) to make sure that
everything is working properly. An inquiry should produce lots of packets with
the LAP 0x9e8b33.</p>

<p>Once you have seen a LAP multiple times, you can be confident that it is a
genuine Bluetooth piconet. To find the next byte of the address, the UAP, we
can use:</p>

<code>$ ubertooth-rx -l [LAP]</code>

<p>In this mode ubertooth-rx only detects packets from the given piconet and
uses them to determine the next byte of the address and some of the internal
clock value.</p>

<p>For more information on this process, and the challenges involved in 
monitoring Bluetooth connections, please read this 
<a href="http://ubertooth.blogspot.co.uk/2013/02/motivating-problem.html">blog 
post</a>
<h2>Kismet</h2>

<img src="../../images/kismet.png" alt="Kismet-Ubertooth screenshot" />

<p>More advanced Bluetooth sniffing has been implemented in the form of a
plugin for <a href="http://www.kismetwireless.net/">Kismet</a>, the venerable
802.11 monitoring tool. In order to compile the Kismet-Ubertooth plugin, you
will need a Kismet source tree matching the installed version. The easiest way
to make this work is to uninstall any binary Kismet installation you may have
installed and then download the Kismet source and follow the instructions to
compile and install from the fresh source code. Once Kismet is installed,
follow the instructions in host/kismet/plugin-ubertooth/README to install and
use the plugin.</p>

<p>Notice that Kismet-Ubertooth identifies not only the LAP but also the 8 bit
Upper Address Part (UAP) of detected devices as it is able. This is done by
analyzing the timing and other characteristics of multiple packets over time.
Another advantage of Kismet is that it dumps complete decoded packets to a
pcapbtbb file that can be read with a Wireshark plugin that is distributed with
<a href="http://libbtbb.sourceforge.net/">libbtbb</a>. Full packet decoding is
only possible when the packet's UAP has been determined.</p>

<h2>Where to Go from Here</h2>

<p>I hope you have found this guide helpful in getting to know your Ubertooth
One. The host code for Project Ubertooth is in active development and new
features are being worked on all the time. If you are interested in
contributing to the project, or if you need help or would just like to chat
about Project Ubertooth, join the <a
href="https://lists.sourceforge.net/lists/listinfo/ubertooth-general">ubertooth-general</a>
mailing list. Happy hacking!</p>
;T;
I"!
<h1>Getting Started</h1>

<p>There are three major components of Project Ubertooth:</p>

<ul>
	<li>hardware: The hardware design of Ubertooth One is quite stable. You can
	<a href="../../hardware/build">build</a> one or <a
	href="http://greatscottgadgets.com/">buy</a> one.</li>
	<li>firmware: This is software that executes on the ARM processor on the
	Ubertooth One itself.  This page assumes that you have the USB bootloader
	plus bluetooth_rxtx firmware installed on your board (which is typically
	what is installed at the time of assembly). The bluetooth_rxtx firmware is
	moderately stable but is likely to be enhanced as time goes on.</li>
	<li>host code: This is software running on a general purpose computer
	connected to the Ubertooth One via USB. The sample host code for Project
	Ubertooth is in active development and will likely change a great deal in
	the coming months. If you have not yet built the host code, please follow
	the <a href=../build>build guide</a>.</li>
</ul>

<p>Ubertooth One is a development platform. The true power of the device is
best realized when you start writing your own software and adapting it to your
needs. If you are just getting to know the board, however, it can be helpful to
try out open source code that others have made available. This guide will help
you get started with your Ubertooth One by introducing you to some useful host
code from the Ubertooth software repository.</p>

<h2>Spectrum Analysis</h2>

<img src="../../images/specan_ui.png" alt="spectrum analyzer screenshot" />

<p>The first thing you should try with a new Ubertooth One is real-time
spectrum analysis. Take a look at Jared's <a
href="http://www.sharebrained.com/2011/05/24/ubertooth-spectrum-analysis-fun/">demonstration
video</a> for a preview.</p>

<p>Connect an antenna to your Ubertooth One and plug it into your computer.
(Never operate your Ubertooth One without an antenna connected.) You should see
the RST and 1V8 LEDs illuminate. This indicates that the LPC175x
microcontroller is running (RST) and that power is being supplied to the CC2400
wireless transceiver IC (1V8). The USB LED may also light up if your computer's
operating system has enumerated and configured the device (typical on Linux).
Now you need some host code to tell the Ubertooth One what to do.</p>

<p><a href="http://sourceforge.net/projects/ubertooth/">Download</a> the latest
Project Ubertooth file release or check out current development code from the
<a href="http://sourceforge.net/projects/ubertooth/develop">svn repository</a>
and navigate to the host/specan_ui directory. Take a look at the README file
and make sure that you have installed the prerequisite software. Then execute
ubertooth-specan-ui as described in the README and watch the 2.4 GHz activity
detected by the Ubertooth One.</p>

<p>One possible thing that could go wrong at this point is that your operating
system does not grant you permission to communicate with the USB device.
Depending on your distribution and preference, this can be fixed on Linux
either by adding your user account to the &quot;usb&quot; group or by creating
a new udev rule such as:</p>

<code>$ echo 'ACTION==&quot;add&quot; BUS==&quot;usb&quot; SYSFS{idVendor}==&quot;ffff&quot;
SYSFS{idProduct}==&quot;0004&quot; GROUP:=&quot;plugdev&quot; MODE:=&quot;0660&quot;' &gt;
/etc/udev/rules.d/99-ubertooth.rules</code>

<p>A udev rules file is available in host/bluetooth_rxtx directory in both svn
and the release packages.  Copy it to /etc/udev/rules.d and run the
following as root:</p>

<code>udevadm control --reload-rules</code>

<p>Make sure you are a member of the &quot;plugdev&quot; group or change the
rule to refer to the group of your choice.  After adding the udev rule, unplug
the Ubertooth One, reboot or restart udevd, and plug in the Ubertooth One
again.</p>

<p>During operation of ubertooth-specan-ui the RX LED should illuminate, and
the USR LED should be dimly lit. After you finish trying out
ubertooth-specan-ui reset your Ubertooth One by unplugging it and plugging it
back in.</p>

<h2>LAP Sniffing</h2>

<img src="../../images/ubertooth-lap.png" alt="ubertooth-lap screenshot" />

<p>Bluetooth packets start with a code that is based on the Lower Address Part
(LAP) of a particular Bluetooth Device Address (BD_ADDR). The BD_ADDR is a 48
bit MAC address, just like the MAC address of an Ethernet device. The LAP
consists of the lower 24 bits of the BD_ADDR and is the only part of the
address that is transmitted with every packet.</p>

<p>The most important passive Bluetooth monitoring function is simply capturing
the LAP from each packet transmitted on a channel. LAP sniffing allows you to
identify Bluetooth devices operating in your vicinity.</p>

<p>In order to sniff LAPs, you'll have to compile the tools in
host/bluetooth_rxtx. These are command line programs intended to work with the
bluetooth_rxtx firmware installed on your Ubertooth One. Follow the
instructions in the README file in that directory to install the the
prerequisite <a href="http://libbtbb.sourceforge.net/">libbtbb</a>, a library
for Bluetooth baseband functions. You can install libbtbb from a <a
href="http://sourceforge.net/projects/libbtbb/files/">file release</a> rather
than git if you prefer.</p>

<p>Once libbtbb is installed, just type &quot;make&quot; in the
host/bluetooth_rxtx directory to compile the tools there. Then make sure your
Ubertooth One is plugged in and execute:</p>

<code>$ ubertooth-rx</code>

<p>You should see various random LAPs detected. Due to uncertainties in
identifying Bluetooth packets without prior knowledge of an address, it is
normal for this process to identify false positives. error correction should
mitigate this problem, but a small number of false positives may still be seen.
When you see the same LAP detected more than once, that is very likely an actual
Bluetooth transmission.</p>

<p>Generate some Bluetooth traffic and enjoy the show. I like to use a mobile
phone or other Bluetooth device to perform an inquiry (usually called
&quot;find new Bluetooth devices&quot; or something similar) to make sure that
everything is working properly. An inquiry should produce lots of packets with
the LAP 0x9e8b33.</p>

<p>Once you have seen a LAP multiple times, you can be confident that it is a
genuine Bluetooth piconet. To find the next byte of the address, the UAP, we
can use:</p>

<code>$ ubertooth-rx -l [LAP]</code>

<p>In this mode ubertooth-rx only detects packets from the given piconet and
uses them to determine the next byte of the address and some of the internal
clock value.</p>

<p>For more information on this process, and the challenges involved in 
monitoring Bluetooth connections, please read this 
<a href="http://ubertooth.blogspot.co.uk/2013/02/motivating-problem.html">blog 
post</a>
<h2>Kismet</h2>

<img src="../../images/kismet.png" alt="Kismet-Ubertooth screenshot" />

<p>More advanced Bluetooth sniffing has been implemented in the form of a
plugin for <a href="http://www.kismetwireless.net/">Kismet</a>, the venerable
802.11 monitoring tool. In order to compile the Kismet-Ubertooth plugin, you
will need a Kismet source tree matching the installed version. The easiest way
to make this work is to uninstall any binary Kismet installation you may have
installed and then download the Kismet source and follow the instructions to
compile and install from the fresh source code. Once Kismet is installed,
follow the instructions in host/kismet/plugin-ubertooth/README to install and
use the plugin.</p>

<p>Notice that Kismet-Ubertooth identifies not only the LAP but also the 8 bit
Upper Address Part (UAP) of detected devices as it is able. This is done by
analyzing the timing and other characteristics of multiple packets over time.
Another advantage of Kismet is that it dumps complete decoded packets to a
pcapbtbb file that can be read with a Wireshark plugin that is distributed with
<a href="http://libbtbb.sourceforge.net/">libbtbb</a>. Full packet decoding is
only possible when the packet's UAP has been determined.</p>

<h2>Where to Go from Here</h2>

<p>I hope you have found this guide helpful in getting to know your Ubertooth
One. The host code for Project Ubertooth is in active development and new
features are being worked on all the time. If you are interested in
contributing to the project, or if you need help or would just like to chat
about Project Ubertooth, join the <a
href="https://lists.sourceforge.net/lists/listinfo/ubertooth-general">ubertooth-general</a>
mailing list. Happy hacking!</p>
;T;@MI"/usage/build/;T{;{	;I"H<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Project Ubertooth - Build Guide</title>
    <link rel="stylesheet" type="text/css" href="/style.css" media="screen">
    <meta name="generator" content="nanoc 3.1.6">
  </head>
  <body>
    <div id="main">
      <h1>This build guide is out of date</h1></br>
Up to date instructions for the latest release are available on our
 <a href="https://github.com/greatscottgadgets/ubertooth/wiki/Build-Guide">GitHub wiki</a>

    </div>
    <div id="sidebar">
      <h1>Project Ubertooth</h1>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki">home</a></li>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/releases">download</a></li>
      </ul>
      <h2>usage</h2>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Getting-Started">getting started</a></li>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Build-Guide">build guide</a></li>
      </ul>
      <h2>hardware</h2>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Ubertooth-Zero">Ubertooth Zero</a></li>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Ubertooth-One">Ubertooth One</a></li>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Assembling-Hardware">build guide</a></li>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Programming">programming</a></li>
      </ul>
      <h2>firmware</h2>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Firmware">developing</a></li>
      </ul>
      <h2>host code</h2>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Software">developing</a></li>
      </ul>
      <h2>help</h2>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Getting-Help">Getting Help</a></li>
        <li><a href="https://lists.sourceforge.net/lists/listinfo/ubertooth-general">mailing list</a></li>
      </ul>
    </div>
  </body>
</html>
;T;	I"Í<h1>This build guide is out of date</h1></br>
Up to date instructions for the latest release are available on our
 <a href="https://github.com/greatscottgadgets/ubertooth/wiki/Build-Guide">GitHub wiki</a>
;T;
I"Í<h1>This build guide is out of date</h1></br>
Up to date instructions for the latest release are available on our
 <a href="https://github.com/greatscottgadgets/ubertooth/wiki/Build-Guide">GitHub wiki</a>
;T;@SI"/firmware/develop/;T{;{	;I"Î<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Project Ubertooth - Developing Firmware</title>
    <link rel="stylesheet" type="text/css" href="/style.css" media="screen">
    <meta name="generator" content="nanoc 3.1.6">
  </head>
  <body>
    <div id="main">
      <h1>Developing Firmware</h1>

<p>You'll need a toolchain that supports ARM Cortex-M3.  The Makefiles in
Project Ubertooth are designed for GCC and a Linux-based toolchain,
specifically the free installation provided at <a
href="https://launchpad.net/gcc-arm-embedded">https://launchpad.net/gcc-arm-embedded</a>,
but it should be possible to compile firmware with any development environment
for the Cortex-M3.  Just unpack the archive and add the bin directory to your
PATH.</p>

<p>Prior to r518, we used the <a
href="http://www.codesourcery.com/">Codesourcery</a> toolchain, but it has
become harder to locate.</p>


<p>Although firmware source and binary images can be found in the 
<a href="https://github.com/greatscottgadgets/ubertooth/releases">release downloads</a>, 
you will probably want fresh code from <a
href="https://www.github.com/greatscottgadgets/ubertooth">git</a>.</p>

<p>Ubertooth Zero and Ubertooth One are not binary compatible.  The default
target is Ubertooth One.  If you are compiling firmware for Ubertooth Zero, set
the environment variable BOARD = UBERTOOTH_ZERO.</p>

    </div>
    <div id="sidebar">
      <h1>Project Ubertooth</h1>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki">home</a></li>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/releases">download</a></li>
      </ul>
      <h2>usage</h2>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Getting-Started">getting started</a></li>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Build-Guide">build guide</a></li>
      </ul>
      <h2>hardware</h2>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Ubertooth-Zero">Ubertooth Zero</a></li>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Ubertooth-One">Ubertooth One</a></li>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Assembling-Hardware">build guide</a></li>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Programming">programming</a></li>
      </ul>
      <h2>firmware</h2>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Firmware">developing</a></li>
      </ul>
      <h2>host code</h2>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Software">developing</a></li>
      </ul>
      <h2>help</h2>
      <ul>
        <li><a href="https://github.com/greatscottgadgets/ubertooth/wiki/Getting-Help">Getting Help</a></li>
        <li><a href="https://lists.sourceforge.net/lists/listinfo/ubertooth-general">mailing list</a></li>
      </ul>
    </div>
  </body>
</html>
;T;	I"K<h1>Developing Firmware</h1>

<p>You'll need a toolchain that supports ARM Cortex-M3.  The Makefiles in
Project Ubertooth are designed for GCC and a Linux-based toolchain,
specifically the free installation provided at <a
href="https://launchpad.net/gcc-arm-embedded">https://launchpad.net/gcc-arm-embedded</a>,
but it should be possible to compile firmware with any development environment
for the Cortex-M3.  Just unpack the archive and add the bin directory to your
PATH.</p>

<p>Prior to r518, we used the <a
href="http://www.codesourcery.com/">Codesourcery</a> toolchain, but it has
become harder to locate.</p>


<p>Although firmware source and binary images can be found in the 
<a href="https://github.com/greatscottgadgets/ubertooth/releases">release downloads</a>, 
you will probably want fresh code from <a
href="https://www.github.com/greatscottgadgets/ubertooth">git</a>.</p>

<p>Ubertooth Zero and Ubertooth One are not binary compatible.  The default
target is Ubertooth One.  If you are compiling firmware for Ubertooth Zero, set
the environment variable BOARD = UBERTOOTH_ZERO.</p>
;T;
I"K<h1>Developing Firmware</h1>

<p>You'll need a toolchain that supports ARM Cortex-M3.  The Makefiles in
Project Ubertooth are designed for GCC and a Linux-based toolchain,
specifically the free installation provided at <a
href="https://launchpad.net/gcc-arm-embedded">https://launchpad.net/gcc-arm-embedded</a>,
but it should be possible to compile firmware with any development environment
for the Cortex-M3.  Just unpack the archive and add the bin directory to your
PATH.</p>

<p>Prior to r518, we used the <a
href="http://www.codesourcery.com/">Codesourcery</a> toolchain, but it has
become harder to locate.</p>


<p>Although firmware source and binary images can be found in the 
<a href="https://github.com/greatscottgadgets/ubertooth/releases">release downloads</a>, 
you will probably want fresh code from <a
href="https://www.github.com/greatscottgadgets/ubertooth">git</a>.</p>

<p>Ubertooth Zero and Ubertooth One are not binary compatible.  The default
target is Ubertooth One.  If you are compiling firmware for Ubertooth Zero, set
the environment variable BOARD = UBERTOOTH_ZERO.</p>
;T;@Y:versioni